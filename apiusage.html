<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>FLAME: API Usage (C++ and Python)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FLAME
   &#160;<span id="projectnumber">devel</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">FLAME documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">API Usage (C++ and Python) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="apiusagecpp"></a>
C++ Simulation API Usage</h1>
<p>The example <a class="el" href="examples_sim_cpp.html">examples/sim.cpp</a> demonstrates the basic process of running a simulation against an existing sim_type and set of Elements. This is a simplified version of <a class="el" href="cli_8cpp_source.html">cli.cpp</a>, which is compiled as the run_flame executable.</p>
<p>Most user code will only need <a class="el" href="base_8h_source.html">base.h</a> and <a class="el" href="config_8h_source.html">config.h</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;flame/config.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;flame/base.h&quot;</span></div>
</div><!-- fragment --><p> Before constructing a <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a> it is necessary to register any "sim_type"s to be used. This will typically be the first thing a program does.</p>
<div class="fragment"><div class="line">        registerLinear();</div>
</div><!-- fragment --><p> Running the simulation with the C++ API begins by populating a <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>. This will often by done using the lattice parser (<a class="el" href="class_g_l_p_s_parser.html" title="Interface to lattice file parser. ">GLPSParser</a>).</p>
<p>Parsing will succeed as long as the file is syntactically correct. For example, "sim_type" and element types are not validated.</p>
<div class="fragment"><div class="line">        std::auto_ptr&lt;Config&gt; conf;</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="class_g_l_p_s_parser.html">GLPSParser</a> parser;</div>
<div class="line">            conf.reset(parser.<a class="code" href="class_g_l_p_s_parser.html#ab170625606f97ffae6d2a5e2e6f48db8">parse_file</a>(argv[1]));</div>
<div class="line">        }</div>
</div><!-- fragment --><p> Next construct a <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a>. It is at this step that "sim_type" and element types are validated.</p>
<div class="fragment"><div class="line">        Machine mymachine(*conf);</div>
</div><!-- fragment --><p> Now allocate an approprate <a class="el" href="struct_state_base.html" title="The abstract base class for all simulation state objects. ">StateBase</a> based on the "sim_type". More than one <a class="el" href="struct_state_base.html" title="The abstract base class for all simulation state objects. ">StateBase</a> may be allocated and used with a single <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a>. The allocated <a class="el" href="struct_state_base.html" title="The abstract base class for all simulation state objects. ">StateBase</a> must only be used with the <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a> which allocated it.</p>
<p>This <a class="el" href="struct_state_base.html" title="The abstract base class for all simulation state objects. ">StateBase</a> sub-class is be initialized based a <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>. In this example an empty <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a> is provided, which will leave the state with some "sim_type" specific defaults ("sim_type=Vector" defaults to all zeros). Generally this will only be done when the lattice begins with a "source" element, which will overwrite the state based on its <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>.</p>
<p>Alternately, a <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a> can be provided to <a class="el" href="struct_machine.html#abda0d01019361a5b4433a0d60f2c24bd" title="Allocate (with &quot;operator new&quot;) an appropriate State object. ">Machine::allocState()</a> to provide non-default values.</p>
<div class="fragment"><div class="line">        std::auto_ptr&lt;StateBase&gt; thestate(mymachine.allocState());</div>
</div><!-- fragment --><p> The <a class="el" href="struct_machine.html#a032de28b14d81018789d127f75f7524e" title="Pass the given bunch State through this Machine. ">Machine::propagate()</a> method is used to run the simulation. When propagate() returns, the <a class="el" href="struct_state_base.html" title="The abstract base class for all simulation state objects. ">StateBase</a> has been modified to reflect the final state.</p>
<p>By default propagate() starts with the first element and continues through the last element.</p>
<div class="fragment"><div class="line">        mymachine.propagate(thestate.get());</div>
</div><!-- fragment --><p> Before exiting some cleanup may be to clear the registry of "sim_type"s.</p>
<div class="fragment"><div class="line">        <a class="code" href="struct_machine.html#ac39a37c2d50d36a3124812c165891358">Machine::registeryCleanup</a>();</div>
</div><!-- fragment --> <h1><a class="anchor" id="apiusagepy"></a>
Python Simulation API Usage</h1>
<p>The example <a class="el" href="examples_sim_cpp.html">examples/sim.cpp</a> demonstrates the basic process of running a simulation using the python API.</p>
<p>Importing "flame" also registers a standard set of "sim_type"s.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;from flame <span class="keyword">import</span> Machine</div>
</div><!-- fragment --><p> Read an parse a lattice file and construct a <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;with open(sys.argv[1], <span class="stringliteral">&quot;</span><span class="stringliteral">r&quot;) as F:</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="stringliteral">    mymachine = <a class="code" href="struct_machine.html">Machine</a>(F)</span></div>
</div><!-- fragment --><p> Allocate a State using an empty <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;thestate = mymachine.allocState({})</div>
</div><!-- fragment --><p> Propagate through all elements.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mymachine.propagate(thestate)</div>
</div><!-- fragment --> <h1><a class="anchor" id="apicreatesim"></a>
Defining a sim_type</h1>
<p>The example defines a new sim_type and two Elements. The simulation itself will be trivial.</p>
<p>The full example can be found in <a class="el" href="examples_customsim_cpp.html">examples/customsim.cpp</a></p>
<h2><a class="anchor" id="apicreatestate"></a>
Define state struct</h2>
<p>The first task is to define the state structure. This contains the variables which define the state of one "bunch". In this case "x" and "xv", which represent a transverse velocity and relative position. In addition the absolute logitudinal <a class="el" href="struct_state_base.html#a095fcae8e6099b6b944c4b60c3cb6cfe" title="absolute longitudinal position at end of Element ">StateBase::pos</a> is inherited.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>State1D : <span class="keyword">public</span> <a class="code" href="struct_state_base.html">StateBase</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> x,  <span class="comment">// transverse position</span></div>
<div class="line">           xv; <span class="comment">// transverse veclocity</span></div>
</div><!-- fragment --><p> The member variables of State1D are initialized from a <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>.</p>
<div class="fragment"><div class="line">    State1D(<span class="keyword">const</span> <a class="code" href="class_config.html">Config</a>&amp; c)</div>
<div class="line">        :<a class="code" href="struct_state_base.html">StateBase</a>(c)</div>
<div class="line">        ,x(c.get&lt;double&gt;(<span class="stringliteral">&quot;x&quot;</span>, 0.0))   <span class="comment">// m</span></div>
<div class="line">        ,xv(c.get&lt;double&gt;(<span class="stringliteral">&quot;xv&quot;</span>, 0.0)) <span class="comment">// m/s</span></div>
<div class="line">    {}</div>
</div><!-- fragment --><p> The remainder of State1D is boilerplate which is repeated for each member variable.</p>
<h2><a class="anchor" id="apicreatesource"></a>
Define source element type</h2>
<p>Now define the "source" element type. By convention this is an element which simply overwrites it's input state with predefined values (eg. from lattice file). So it is simplest to give this struct it's own internal State1D instance.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Element1DSource : <span class="keyword">public</span> <a class="code" href="struct_element_void.html">ElementVoid</a></div>
<div class="line">{</div>
<div class="line">    State1D initial;</div>
</div><!-- fragment --><p> Initialization of the element can also initialize this internal State1D from the same <a class="el" href="class_config.html" title="Associative configuration container. ">Config</a>.</p>
<div class="fragment"><div class="line">    Element1DSource(<span class="keyword">const</span> <a class="code" href="class_config.html">Config</a>&amp; c)</div>
<div class="line">        :<a class="code" href="struct_element_void.html">ElementVoid</a>(c)</div>
<div class="line">        ,initial(c)</div>
<div class="line">    {}</div>
</div><!-- fragment --><p> So the same "x" and "xv" used to initialize the state can be given to a source element.</p>
<div class="fragment"><div class="line">srcname : source, x=0, xv=0.1, L=0.5;</div>
</div><!-- fragment --><p>With this lattice file entry, the "x" and "xv" are used to initialize the internal State1D. "L" is used to initialize <a class="el" href="struct_element_void.html#a44b8266ee5fc33a92e01ed22fd535ba4" title="Longitudual length of this element (added to StateBase::pos) ">ElementVoid::length</a>.</p>
<p>Next define the simulated action of this element with its advance() method. This method should modify it's input State1D. In this case, the source element simply overwrites the input state using its internal State1D.</p>
<div class="fragment"><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> advance(<a class="code" href="struct_state_base.html">StateBase</a>&amp; s)</div>
<div class="line">    {</div>
<div class="line">        s.<a class="code" href="struct_state_base.html#a64dc2c9751d54280dcd39d2424399af7">assign</a>(initial);</div>
<div class="line">        s.<a class="code" href="struct_state_base.html#a095fcae8e6099b6b944c4b60c3cb6cfe">pos</a> += length; <span class="comment">// source element ususaly has zero length, but not required</span></div>
<div class="line">    }</div>
</div><!-- fragment --> <h2><a class="anchor" id="apicreategeneric"></a>
Define another element type</h2>
<p>Now define another "generic" element type which transforms the state in a more interesting way.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Element1DGeneric : <span class="keyword">public</span> <a class="code" href="struct_element_void.html">ElementVoid</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> xa, <span class="comment">// transverse acceleration</span></div>
<div class="line">           tt; <span class="comment">// logitudinal transit time</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">    Element1DGeneric(<span class="keyword">const</span> <a class="code" href="class_config.html">Config</a>&amp; c)</div>
<div class="line">        :<a class="code" href="struct_element_void.html">ElementVoid</a>(c)</div>
<div class="line">        ,xa(c.get&lt;double&gt;(<span class="stringliteral">&quot;A&quot;</span>, 0.0)) <span class="comment">// m/s2</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// length will never change, so only need to compute transit time once</span></div>
<div class="line">        tt = length/C0; <span class="comment">// sec.</span></div>
<div class="line">    }</div>
</div><!-- fragment --><p> Here we see that the name given to <a class="el" href="class_config.html#ac3704499622eb6ca7245b9da3a5cbbc5">Config::get</a> need not match a c++ variable name. Also that some calculations can be done once, and the result stored in a class member variable for later re-use.</p>
<div class="fragment"><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> advance(<a class="code" href="struct_state_base.html">StateBase</a>&amp; s)</div>
<div class="line">    {</div>
<div class="line">        State1D &amp;ST = <span class="keyword">static_cast&lt;</span>State1D&amp;<span class="keyword">&gt;</span>(s); <span class="comment">// safe since sim_type=Simple1D will only use State1D</span></div>
<div class="line"></div>
<div class="line">        ST.pos += length;</div>
<div class="line">        ST.xv  += xa*tt;</div>
<div class="line">        ST.x   += xa*tt*tt;</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The advance() function incrementally updates the state.</p>
<h2><a class="anchor" id="apicreateregister"></a>
Registration</h2>
<p>So far three types have been defined: State1D, Element1DSource, and Element1DGeneric. If nothing further is done there will be no way to make use of this code. As these definitions appear in an anonymous C++ namespace a modern compiler is able to issue a warn that this code is unreachable.</p>
<p>In order for this code to be reachable it must be tied into the FLAME framework in some way. This is accomplished with <a class="el" href="struct_machine.html#a9bd2aeb4f940b3dda330219bdd74a00e" title="Register a new State with the simulation framework. ">Machine::registerState</a> and <a class="el" href="struct_machine.html#a72e90116772c6d481d0f516af2a3b6bb" title="Register a new Element type with the simulation framework. ">Machine::registerElement</a>.</p>
<p>By convention a function "register...()" is defined, which must be called exactly once before <a class="el" href="struct_machine.html" title="The core simulate Machine engine. ">Machine</a> can make use of these definitions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> register1D()</div>
<div class="line">{</div>
<div class="line">    Machine::registerState&lt;State1D&gt;(<span class="stringliteral">&quot;Simple1D&quot;</span>);</div>
<div class="line"></div>
<div class="line">    Machine::registerElement&lt;Element1DSource&gt;(<span class="stringliteral">&quot;Simple1D&quot;</span>, <span class="stringliteral">&quot;source&quot;</span>);</div>
<div class="line">    Machine::registerElement&lt;Element1DGeneric&gt;(<span class="stringliteral">&quot;Simple1D&quot;</span>, <span class="stringliteral">&quot;generic&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now to make use Simple1D we expand on <a class="el" href="examples_sim_cpp.html">examples/sim.cpp</a></p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> lattice[] = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;sim_type = \&quot;Simple1D\&quot;;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;src   : source, x = 1e-5, xv = 1e-6;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;elem1 : generic, A = 1,  L = 10;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;elem2 : generic, A = -2, L = 10;\n&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;example : LINE = (src, elem1, elem2);\n&quot;</span></div>
<div class="line">;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        register1D();</div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;Config&gt; conf;</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="class_g_l_p_s_parser.html">GLPSParser</a> parser;</div>
<div class="line">            conf.reset(parser.<a class="code" href="class_g_l_p_s_parser.html#ae0e035c615dd2612660d4e1d0406ccb6">parse_byte</a>(lattice, <span class="keyword">sizeof</span>(lattice)-1));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">/* conf now contains (using python notation)</span></div>
<div class="line"><span class="comment">         * {&quot;sim_type&quot;:&quot;Simple1D&quot;,</span></div>
<div class="line"><span class="comment">         *  &quot;elements&quot;: [</span></div>
<div class="line"><span class="comment">         *    {&quot;type&quot;:&quot;source&quot;,  &quot;name&quot;:&quot;src&quot;, &quot;x&quot;:1e-5, &quot;xv&quot;:1e-6},</span></div>
<div class="line"><span class="comment">         *    {&quot;type&quot;:&quot;generic&quot;, &quot;name&quot;:&quot;elem1&quot;, &quot;A&quot;:1.0,  &quot;L&quot;:10.0},</span></div>
<div class="line"><span class="comment">         *    {&quot;type&quot;:&quot;generic&quot;, &quot;name&quot;:&quot;elem2&quot;, &quot;A&quot;:-2.0, &quot;L&quot;:10.0},</span></div>
<div class="line"><span class="comment">         *  ],</span></div>
<div class="line"><span class="comment">         * }</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        Machine mymachine(*conf);</div>
<div class="line">        <span class="comment">/* During Machine construction</span></div>
<div class="line"><span class="comment">         * sim_type=Simple1D with type=source selects Element1DSource, which is constructed once</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * sim_type=Simple1D with type=source selects Element1DGeneric, which is constructed twice.</span></div>
<div class="line"><span class="comment">         *  first with A=1, then a second time with A=-2</span></div>
<div class="line"><span class="comment">         *</span></div>
<div class="line"><span class="comment">         * mymachine now has 3 elements.  mymachine.size()==3</span></div>
<div class="line"><span class="comment">         */</span></div>
<div class="line"></div>
<div class="line">        mymachine.set_trace(&amp;std::cout); <span class="comment">// print intermediates</span></div>
<div class="line"></div>
<div class="line">        std::auto_ptr&lt;StateBase&gt; thestate(mymachine.allocState());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// propagate through the source element to initialize the state based on</span></div>
<div class="line">        <span class="comment">// values of &quot;x&quot; and &quot;xv&quot; from the lattice</span></div>
<div class="line">        mymachine.propagate(thestate.get(), 0, 1);</div>
<div class="line"></div>
<div class="line">        std::cout&lt;&lt;<span class="stringliteral">&quot;Source state &quot;</span>&lt;&lt;*thestate&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// propagate through remaining elements</span></div>
<div class="line">        mymachine.propagate(thestate.get(), 1);</div>
<div class="line"></div>
<div class="line">        std::cout&lt;&lt;<span class="stringliteral">&quot;Final state &quot;</span>&lt;&lt;*thestate&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <a class="code" href="struct_machine.html#ac39a37c2d50d36a3124812c165891358">Machine::registeryCleanup</a>();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">catch</span>(std::exception&amp; e) {</div>
<div class="line">        std::cerr&lt;&lt;<span class="stringliteral">&quot;Error: &quot;</span>&lt;&lt;e.what()&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 16 2016 23:09:35 for FLAME by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
